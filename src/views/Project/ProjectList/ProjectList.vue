<script setup>
import Fuse from 'fuse.js'
import { orderBy as orderArrayBy, property } from 'lodash'
import { computed, ref, onBeforeMount } from 'vue'

import PageContainer from '@/components/PageContainer/PageContainer'
import PageHeader from '@/components/PageHeader/PageHeader'
import PageToolbar from '@/components/PageToolbar/PageToolbar'
import ProjectEntries from '@/components/Project/ProjectEntries/ProjectEntries'
import RowPaginationProjects from '@/components/RowPagination/RowPaginationProjects'
import { useUrlParam, useUrlParamWithStore, useUrlParamsWithStore } from '@/composables/url-params'
import { useCore } from '@/composables/core'
import { useAppStore } from '@/store/modules'
import useMode from '@/composables/mode'

const { core } = useCore()
const { isServer } = useMode()
const appStore = useAppStore()
const searchQuery = useUrlParam('q', '')

const page = useUrlParam('page', {
  transform: (value) => parseInt(value),
  initialValue: 1
})

const perPage = useUrlParamWithStore('perPage', {
  transform: (value) => Math.max(10, parseInt(value)),
  get: () => appStore.getSettings('projectList', 'perPage'),
  set: (value) => appStore.setSettings({ view: 'projectList', perPage: parseInt(value) })
})

const documentsCountByProject = ref({})

const fetchDocumentsCountByProject = async () => {
  const query = { match: { type: 'Document' } }
  const projectIds = core.projectIds.join(',')
  const { aggregations } = await core.api.elasticsearch.countByProject(projectIds, query)
  const buckets = aggregations?.index?.buckets ?? []
  // Finally we store the count of documents by project
  buckets.forEach(({ key, doc_count: count }) => (documentsCountByProject.value[key] = count))
}

const maxExtractionDateByProject = ref({})

const fetchMaxExtractionDateByProject = async () => {
  const query = { match: { type: 'Document' } }
  const projectIds = core.projectIds.join(',')
  const { aggregations } = await core.api.elasticsearch.maxExtractionDateByProject(projectIds, query)
  const buckets = aggregations?.index?.buckets ?? []
  // Finally we store the max extraction date by project
  buckets.forEach(({ key, maxExtractionDate }) => (maxExtractionDateByProject.value[key] = maxExtractionDate.value))
}

onBeforeMount(fetchDocumentsCountByProject)
onBeforeMount(fetchMaxExtractionDateByProject)

const extendedProjects = computed(() => {
  return core.projects.map(({ name, ...project }) => {
    const documentsCount = documentsCountByProject.value?.[name] ?? 0
    const updateDate = new Date(maxExtractionDateByProject.value?.[name] ?? project.updateDate ?? project.creationDate)
    return { ...project, name, documentsCount, updateDate }
  })
})

const fuse = computed(() => {
  const keys = ['name', 'label']
  const options = { shouldSort: false, threshold: 0.1, keys }
  return new Fuse(extendedProjects.value, options)
})

const filteredProjects = computed(() => {
  if (searchQuery.value) {
    return fuse.value.search(searchQuery.value).map(property('item'))
  }
  return extendedProjects.value
})

const sortedProjects = computed(() => {
  const [sort, order] = orderBy.value
  return orderArrayBy(filteredProjects.value, sort, order)
})

const projects = computed(() => {
  const start = (page.value - 1) * perPage.value
  return sortedProjects.value.slice(start, start + perPage.value)
})

const layout = useUrlParamWithStore('layout', {
  get: () => appStore.getSettings('projectList', 'layout'),
  set: (layout) => appStore.setSettings({ view: 'projectList', layout })
})

const orderBy = useUrlParamsWithStore(['sort', 'order'], {
  get: () => appStore.getSettings('projectList', 'orderBy'),
  set: (sort, order) => appStore.setSettings({ view: 'projectList', orderBy: [sort, order] })
})

const sort = computed({
  get: () => orderBy.value?.[0],
  set: (value) => (orderBy.value = [value, order.value])
})

const order = computed({
  get: () => orderBy.value?.[1],
  set: (value) => (orderBy.value = [sort.value, value])
})

const toAddRoute = computed(() => {
  return isServer.value ? null : { name: 'project.new' }
})
</script>

<template>
  <page-container fluid deck class="project-list">
    <page-header :to-add="toAddRoute" />
    <page-toolbar
      v-model:searchQuery="searchQuery"
      v-model:page="page"
      :per-page="perPage"
      :total-rows="filteredProjects.length"
      searchable
      paginable
      :search-placeholder="$t('projectList.searchPlaceholder')"
    >
      <template #pagination="{ totalRows }">
        <row-pagination-projects v-model="page" :total-rows="totalRows" :per-page="+perPage" />
      </template>
    </page-toolbar>
    <project-entries v-model:sort="sort" v-model:order="order" :projects="projects" :layout="layout" />
  </page-container>
</template>
