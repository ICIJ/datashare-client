<template>
  <div class="tree-view" :class="{ 'tree-view--compact': compact }">
    <b-collapse :visible="!noHeader">
      <div class="tree-view__header d-flex flex-row align-items-center text-nowrap">
        <tree-breadcrumb
          :path="path"
          :max-directories="compact ? 2 : 5"
          no-datadir
          datadir-label
          @input="$emit('update:path', $event)"
        />
        <transition :name="transition">
          <div v-if="!$wait.waiting('loading tree view data')">
            <router-link
              v-if="searchable"
              :to="searchInPathRoute(path)"
              class="tree-view__header__search ms-2 btn-primary btn btn-sm rounded-pill"
            >
              <fa icon="search"></fa>
              {{ $t('treeView.searchPath') }}
            </router-link>
            <span v-if="size" class="tree-view__header__size ms-3">
              <fa icon="weight"></fa>
              {{ humanSize(total, false, $t('human.size')) }}
            </span>
            <span
              v-if="count"
              :title="$tc('treeView.hits', hits, { hits })"
              class="tree-view__header__hits ms-2 badge text-bg-light rounded-pill"
            >
              {{ humanNumber(hits, $tm('human.number')) }} {{ $tc('treeView.docs', hits) }}
            </span>
          </div>
        </transition>
      </div>
    </b-collapse>
    <!-- @slot Area to insert content above the tree view -->
    <slot name="above"></slot>
    <v-wait for="loading tree view data" :transition="transition">
      <template #waiting>
        <div class="tree-view__spinner text-center">
          <fa icon="circle-notch" spin size="2x"></fa>
        </div>
      </template>
      <div>
        <b-form-checkbox-group v-model="selected">
          <ul class="list-group list-group-flush tree-view__directories">
            <li
              v-if="hits && selectable"
              class="list-group-item d-flex flex-row align-items-center tree-view__directories__item tree-view__directories__item--hits"
            >
              <b-form-checkbox
                :id="allDirectoriesInputId"
                :value="toDirectory(path)"
                class="tree-view__directories__item__checkbox"
              />
              <label class="flex-grow-1 m-0" :for="allDirectoriesInputId">
                {{ $t('treeView.all') }} <em>({{ $t('treeView.includingIndividualDocuments') }})</em>
              </label>
              <div class="ms-2 badge text-bg-light rounded-pill" :title="$n(hits)">
                <span v-if="compact">
                  {{ $n(hits) }}
                </span>
                <span v-else> {{ humanNumber(hits) }} {{ $tc('treeView.docs', hits) }} </span>
              </div>
            </li>
            <li
              v-for="directory in directories"
              :key="directory.key"
              class="list-group-item d-flex flex-row align-items-center tree-view__directories__item"
            >
              <b-form-checkbox
                v-if="selectable"
                :value="toDirectory(directory.key)"
                class="tree-view__directories__item__checkbox"
              />
              <a
                class="tree-view__directories__item__label flex-grow-1"
                href
                @click.prevent="$emit('update:path', directory.key)"
              >
                {{ getBasename(directory.key) }}
              </a>
              <router-link
                v-if="searchable"
                :to="searchInPathRoute(directory.key)"
                class="tree-view__directories__item__search ms-2 btn-primary btn btn-sm rounded-pill"
              >
                <fa icon="search"></fa>
                <span>&nbsp;{{ $t('treeView.searchPath') }}</span>
              </router-link>
              <div
                v-if="size && directory.contentLength"
                class="tree-view__directories__item__content-length fw-bold ms-2"
                :title="$n(directory.contentLength.value)"
              >
                {{ humanSize(directory.contentLength.value, false, $t('human.size')) }}
              </div>
              <span
                v-if="count"
                :title="$tc('treeView.hits', directory.doc_count, { hits: $n(directory.doc_count) })"
                class="tree-view__directories__item__count ms-2 badge text-bg-light rounded-pill"
              >
                <span v-if="!directory.doc_count"> - </span>
                <span v-else-if="compact">
                  {{ $n(directory.doc_count) }}
                </span>
                <span v-else>
                  {{ humanNumber(directory.doc_count) }} {{ $tc('treeView.docs', directory.doc_count) }}
                </span>
              </span>
              <span
                v-if="!noBars"
                class="tree-view__directories__item__bar"
                :style="{ width: totalPercentage(directory.contentLength.value) }"
              ></span>
            </li>
            <li
              v-if="!selectable && !directories.length"
              class="list-group-item tree-view__directories__item tree-view__directories__item--no-folders text-center"
            >
              {{ $t('widget.noFolders') }}
            </li>
          </ul>
          <infinite-loading v-if="useInfiniteScroll" :identifier="infiniteScrollId" @infinite="nextLoadData">
            <template #spinner><span></span></template>
            <template #complete><span></span></template>
          </infinite-loading>
        </b-form-checkbox-group>
      </div>
    </v-wait>
    <!-- @slot Area to insert content bellow the tree view -->
    <slot name="bellow"></slot>
  </div>
</template>

<script>
import {
  difference,
  flatten,
  filter,
  get,
  identity,
  includes,
  noop,
  round,
  trim,
  trimEnd,
  uniq,
  uniqBy,
  uniqueId,
  last
} from 'lodash'
import bodybuilder from 'bodybuilder'
import { waitFor } from 'vue-wait'
import InfiniteLoading from 'v3-infinite-loading'

import TreeBreadcrumb from '@/components/TreeBreadcrumb'
import humanNumber from '@/filters/humanNumber'
import humanSize from '@/filters/humanSize'
import { wildcardRegExpPattern, iwildcardMatch } from '@/utils/strings'

/**
 * A view listing directories from a specific path.
 */
export default {
  name: 'TreeView',
  components: {
    InfiniteLoading,
    TreeBreadcrumb
  },
  props: {
    /**
     * List directories from this path.
     * @model
     */
    path: {
      type: String
    },
    /**
     * The ES indices
     */
    projects: {
      type: Array,
      default: () => ['local-datashare']
    },
    /**
     * A list of selected paths
     */
    selectedPaths: {
      type: Array,
      default: () => []
    },
    /**
     * Either or not paths can be selected
     */
    selectable: {
      type: Boolean,
      default: false
    },
    /**
     * Show the number of documents by directory.
     */
    count: {
      type: Boolean,
      default: false
    },
    /**
     * Show the size of documents by directory.
     */
    size: {
      type: Boolean,
      default: false
    },
    /**
     * Deactivate the header (including breadcrumb and total)
     */
    noHeader: {
      type: Boolean,
      default: false
    },
    /**
     * Deactivate the bar chart bellow each folder
     */
    noBars: {
      type: Boolean,
      default: false
    },
    /**
     * Display the tree view in compact mode
     */
    compact: {
      type: Boolean,
      default: false
    },
    /**
     * Function to apply to the elasticsearch body before it's build
     */
    preBodyBuild: {
      type: Function,
      default: identity
    },
    /**
     * Either or not results should be loaded on scroll
     */
    infiniteScroll: {
      type: Boolean,
      default: true
    },
    /**
     * Display a link to search by path.
     */
    searchable: {
      type: Boolean,
      default: false
    },
    /**
     * Key to sort the directories
     */
    sortBy: {
      type: String,
      default: 'contentLength',
      validator: (order) => includes(['_count', '_key', 'contentLength'], order)
    },
    /**
     * Order to sort by (asc or desc)
     */
    sortByOrder: {
      type: String,
      default: 'desc',
      validator: (order) => includes(['asc', 'desc'], order)
    },
    /**
     * If the true, the document count and size of each directory will include
     * child documents.
     */
    includeChildrenDocuments: {
      type: Boolean
    },
    /**
     * Query to filter the directory by name.
     */
    query: {
      type: String
    },
    /**
     * Transition to apply
     */
    transition: {
      type: String,
      default: 'fade'
    }
  },
  emits: ['update:path', 'update:selectedPaths', 'update:directories', 'checked'],
  data() {
    return {
      pages: [],
      tree: [],
      infiniteScrollId: uniqueId('infinite-scroll-'),
      allDirectoriesInputId: uniqueId('all-directories-input-'),
      pathSeparator: this.$core.config.get('pathSeparator', '/')
    }
  },
  computed: {
    lastPage() {
      return this.pages[this.pages.length - 1]
    },
    lastPageDirectories() {
      return get(this.lastPage, 'aggregations.byDirname.buckets', [])
    },
    offset() {
      return get(this, 'directories.length', 0)
    },
    nextOffset() {
      return this.offset + this.bucketsSize
    },
    bucketsSize() {
      return 50
    },
    order() {
      return { [this.sortBy]: this.sortByOrder }
    },
    hasQuery() {
      return this.query && this.query.trim()
    },
    wildcardPath() {
      return [this.path, this.wildcardQuery].join(this.pathSeparator)
    },
    wildcardQuery() {
      if (this.hasQuery) {
        // This ensure the query with one (and only one) wildcard
        return '*' + trim(this.query, '*') + '*'
      }
      return '*'
    },
    treeChildren() {
      return filter(get(this.tree, 'contents', []), { type: 'directory' })
    },
    treeAsPagesBuckets() {
      return (
        this.treeChildren
          // Only keep directories
          .filter(({ type }) => type === 'directory')
          // Only keep the one matching with the query
          .filter(({ name }) => {
            if (this.hasQuery) {
              // Compare only with the dirname
              const dirname = name.split(this.pathSeparator).pop()
              // And use case-insentive wildcard match
              return iwildcardMatch(dirname, this.wildcardQuery)
            }
            return true
          })
          // Transform it to match with the ES aggregation format
          .map(({ name: key }) => {
            return { key, contentLength: 0, doc_count: 0 }
          })
      )
    },
    pagesBuckets() {
      return this.pages.map((p) => get(p, 'aggregations.byDirname.buckets', []))
    },
    flattenPagesBuckets() {
      return flatten(this.pagesBuckets)
    },
    directories() {
      return uniqBy([...this.flattenPagesBuckets, ...this.treeAsPagesBuckets], (dir) => dir.key)
    },
    hits() {
      return get(this, 'lastPage.hits.total.value', 0)
    },
    total() {
      return get(this, 'lastPage.aggregations.totalContentLength.value', -1)
    },
    includeOption() {
      return (
        this.queryPathTokens
          // Convert the path with a wildcard to regex
          .map(wildcardRegExpPattern)
          // Wrap each regex with
          .map((pattern) => `(${pattern})`)
          // Finally, concatenate refex
          .join('|')
      )
    },
    excludeOption() {
      return (
        this.subPathTokens
          // Ensure path are normalized for Windows users
          .map(this.normalizePath)
          // Wrap each regex with
          .map((pattern) => `(${pattern})`)
          // Finally, concatenate refex
          .join('|')
      )
    },
    aggregationOptions() {
      return {
        include: this.includeOption,
        exclude: this.excludeOption,
        size: this.nextOffset,
        order: this.order
      }
    },
    reachedTheEnd() {
      return this.lastPageDirectories.length < this.bucketsSize
    },
    useInfiniteScroll() {
      return this.infiniteScroll && this.offset > 0 && !this.reachedTheEnd
    },
    pathTokens() {
      /**
       * @deprecated Since 9.4.2, the dirname field is tokenized using the
       * "lowercase" filter. To ensure retro-compatibility, we apply lookup for
       * the path in both lowercase and orignal value for this field (if they
       * are different).
       */
      return uniq([this.path, this.path.toLowerCase()])
    },
    queryPathTokens() {
      /**
       * @deprecated Since 9.4.2, the dirname field is tokenized using the
       * "lowercase" filter. To ensure retro-compatibility, we apply lookup for
       * the path in both lowercase and orignal value for this field (if they
       * are different).
       */
      return uniq([this.wildcardPath, this.wildcardPath.toLowerCase()])
    },
    subPathTokens() {
      return this.pathTokens.map((token) => {
        return [token, '.*', '.*'].join(this.pathSeparator)
      })
    },
    usesWindowsSeparator() {
      return this.pathSeparator === '\\'
    },
    selected: {
      get() {
        return this.toDirectories(this.selectedPaths)
      },
      set(paths) {
        // Ensute the given paths are directories paths
        paths = this.toDirectories(paths)
        const diff = difference(paths, this.selectedPaths)
        // True if the current path just has been selected.
        // This is equivalent to select "all.
        if (diff.includes(this.dirPath)) {
          paths = this.pathsWihtoutSiblings(paths)
          // True if a sibling directory is selected, not the current path
        } else if (diff.length && paths.includes(this.dirPath)) {
          paths = this.pathsWithoutCurrent(paths)
        }
        return this.selectPaths(paths)
      }
    },
    dirPath() {
      return this.toDirectory(this.path)
    }
  },
  watch: {
    query() {
      return this.reloadDataWithSpinner()
    },
    path() {
      return this.reloadDataWithSpinner()
    },
    order() {
      return this.reloadDataWithSpinner()
    },
    directories: {
      deep: true,
      handler() {
        /**
         * Called when more directories are loaded
         */
        this.$emit('update:directories', this.directories)
      }
    }
  },
  async created() {
    await this.loadDataWithSpinner({ clearPages: true })
  },
  methods: {
    humanSize,
    humanNumber,
    normalizePath(path) {
      if (this.usesWindowsSeparator) {
        return path.split('\\').join('\\\\')
      }
      return path
    },
    getBasename(value) {
      return last(value.split(this.pathSeparator))
    },
    toDirectory(path) {
      return trimEnd(path, this.pathSeparator) + this.pathSeparator
    },
    toDirectories(paths) {
      return paths.map(this.toDirectory)
    },
    selectPaths(paths) {
      // Ensure the paths are directories paths (with a tailing /)
      const dirPaths = this.toDirectories(paths)
      /**
       * The selectedPaths are updated (deprecated event).
       *
       * @event checked
       */
      this.$emit('checked', dirPaths)
      /**
       * The selectedPaths are updated. New way to propagate change compatible with the .sync modifier.
       *
       * @see https://vuejs.org/v2/guide/components-custom-events.html#sync-Modifier
       * @event update:selectedPaths
       */
      this.$emit('update:selectedPaths', dirPaths)
    },
    pathsWihtoutSiblings(paths) {
      return filter(paths, (path) => {
        return path === this.path || !path.startsWith(this.path)
      })
    },
    pathsWithoutCurrent(paths) {
      return filter(paths, (path) => {
        return path && path !== this.path
      })
    },
    totalPercentage(value) {
      if (this.total > 0) {
        return round((value / this.total) * 100, 2) + '%'
      } else {
        return '0%'
      }
    },
    bodybuilderBase({ from = 0, size = 100 } = {}) {
      const body = bodybuilder().size(0).rawOption('track_total_hits', true)
      // Only the extraction level is an optional query
      if (!this.includeChildrenDocuments) {
        body.andQuery('match', 'extractionLevel', 0)
      }
      return body
        .andQuery('bool', (bool) => {
          // Add all path tokens in a "should" statement
          this.pathTokens.forEach((t) => bool.orQuery('term', 'dirname.tree', t))
          return bool
        })
        .andQuery('match', 'type', 'Document')
        .agg('terms', 'dirname.tree', this.aggregationOptions, 'byDirname', (b) => {
          return b.agg('sum', 'contentLength', 'contentLength').agg(
            'bucket_sort',
            {
              size,
              from
            },
            'bucket_truncate'
          )
        })
        .agg('sum', 'contentLength', 'totalContentLength')
    },
    async nextLoadData($infiniteLoadingState) {
      await this.loadData()
      // Did we reach the end?
      const method = this.reachedTheEnd ? 'complete' : 'loaded'
      // Call the right method (with "noop" as safety net in case the method can't be found)
      return get($infiniteLoadingState, method, noop)()
    },
    async reloadDataWithSpinner() {
      await this.loadDataWithSpinner({ clearPages: true })
      this.infiniteScrollId = uniqueId()
    },
    loadDataWithSpinner: waitFor('loading tree view data', function (...args) {
      return this.loadData(...args)
    }),
    async loadData({ clearPages = false } = {}) {
      const index = this.projects.join(',')
      const from = clearPages ? 0 : this.offset
      const size = this.bucketsSize
      const body = this.preBodyBuild(this.bodybuilderBase({ from, size })).build()
      const preference = 'tree-view-paths'
      const res = await this.$core.api.elasticsearch.search({ index, body, preference, size: 0 })
      // Clear the list of pages (to start over!)
      if (clearPages) await this.clearPagesAndLoadTree()
      // Add the result as a page
      this.pages.push(res)
    },
    clearPages() {
      return this.pages.splice(0, this.pages.length)
    },
    async clearPagesAndLoadTree() {
      this.clearPages()
      // Only load the tree if we clear out the pages
      // and entirely load the folder. This way we avoid
      // load directories from the /tree API when they are
      // already present in next result page of the
      // ElasticSearch aggregation.
      //
      // The /tree API is disabled in server so we ensure
      // the mode is correct before running it.
      if (this.reachedTheEnd && this.$config.get('mode') !== 'SERVER') {
        await this.loadTree()
      }
    },
    async loadTree() {
      this.tree = await this.$core.api.tree(this.path)
    },
    searchInPathRoute(path) {
      const indices = this.projects
      const query = { 'f[path]': path, indices }
      return { name: 'search', query }
    }
  }
}
</script>

<style lang="scss">
@keyframes slidingBar {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(0%);
  }
}

.tree-view {
  overflow: hidden;

  .fade-enter-active,
  .fade-leave-active {
    transition: opacity 0.5s;
  }
  .fade-enter-from,
  .fade-leave-to {
    opacity: 0;
  }

  &__spinner {
    padding: $spacer * 3;

    .tree-view--compact & {
      padding: $spacer;
    }
  }

  &__header {
    padding: $list-group-item-padding-y $list-group-item-padding-x;
    color: inherit;

    .tree-view--compact & {
      padding: $spacer * 0.5;
    }
  }

  &__directories {
    &__item {
      position: relative;

      .form-check-inline {
        margin-right: 0.5rem;
      }

      .tree-view--compact & {
        padding: 0.25rem 0.75rem;

        &--no-folders {
          padding: 0.5rem;
        }
      }

      &__search.btn {
        margin: -0.5rem 0;
        display: none;
        text-align: center;
        line-height: 1.5;
        width: 100%;
        max-width: calc(1rem + #{$btn-padding-x-sm * 2});
        transition: max-width 300ms;
        white-space: nowrap;
        overflow: hidden;

        & > span {
          opacity: 0;
          transition: opacity 300ms;
        }

        &:hover {
          width: auto;
          max-width: 200px;

          & > span {
            opacity: 1;
          }
        }
      }

      &:hover &__search.btn {
        display: inline-block;
      }

      &__bar {
        animation: slidingBar 200ms forwards;
        background: $primary;
        bottom: 0;
        height: 3px;
        left: 0;
        position: absolute;
        transform: translateX(-100%);
      }

      @for $i from 0 through 100 {
        &:nth-child(#{$i}) &__bar {
          animation-delay: $i * 50ms;
        }
      }
    }
  }
}
</style>
