<template>
  <component :is="noBtnGroup ? 'div' : 'b-btn-group'" :vertical="vertical" class="document-actions align-items-center">
    <a
      :id="starBtnId"
      class="document-actions__star btn"
      :class="starBtnClassDefinition"
      href
      @click.prevent="toggleStarDocument()"
    >
      <fa :icon="[isStarred ? 'fa' : 'far', 'star']" fixed-width />
      <span class="ml-2" :class="{ 'sr-only': !starBtnLabel }">
        {{ $t('document.starButton') }}
      </span>
    </a>
    <b-tooltip :target="starBtnId" :placement="tooltipsPlacement">
      {{ $t('document.starFile') }}
    </b-tooltip>

    <template v-if="canIDownload">
      <b-btn-group :class="downloadBtnGroupClass">
        <a
          :id="downloadBtnId"
          class="document-actions__download btn"
          :class="downloadBtnClass"
          :href="document.fullUrl"
          target="_blank"
        >
          <fa icon="download" fixed-width />
          <span class="ml-2" :class="{ 'sr-only': !downloadBtnLabel }">
            {{ $t('document.downloadButton') }}
          </span>
        </a>
        <b-dropdown v-if="hasDownloadDropdown" right toggle-class="py-0" size="sm">
          <b-dropdown-item
            v-if="displayDownloadWithoutMetadata && hasCleanableContentType"
            :href="documentFullUrlWithoutMetadata"
          >
            <fa icon="download" fixed-width />
            {{ $t('document.downloadWithoutMetadata') }}
          </b-dropdown-item>
          <b-dropdown-item
            v-if="displayDownloadExtractedText"
            class="document-actions__download--extracted-text"
            @click="documentOriginalExtractedText"
          >
            <fa icon="file-lines" fixed-width />
            {{ $t('document.downloadExtractedText') }}
          </b-dropdown-item>
          <template v-if="hasRoot">
            <b-dropdown-divider></b-dropdown-divider>
            <b-dropdown-item
              :id="downloadRootBtnId"
              :href="document.fullRootUrl"
              class="document-actions__download--parent"
            >
              <fa icon="box-archive" fixed-width />
              {{ $t('document.downloadRootButton') }}
            </b-dropdown-item>
            <b-dropdown-item
              v-if="hasRootCleanableContentType"
              :href="rootDocumentFullUrlWithoutMetadata"
              class="document-actions__download--parent-without-metadata"
            >
              <fa icon="box-archive" fixed-width />
              {{ $t('document.downloadRootWithoutMetadataButton') }}
            </b-dropdown-item>
          </template>
        </b-dropdown>
      </b-btn-group>
      <b-popover
        :placement="tooltipsPlacement"
        :target="downloadBtnId"
        :title="document.contentTypeLabel"
        triggers="hover focus"
      >
        <document-type-card :document="document" />
      </b-popover>
    </template>

    <router-link-popup
      :id="popupBtnId"
      class="document-actions__popup btn"
      :class="popupBtnClass"
      :to="{ name: 'document-modal', params: document.routerParams }"
    >
      <fa icon="external-link-alt" fixed-width />
      <span class="ml-2" :class="{ 'sr-only': !popupBtnLabel }">
        {{ $t('document.externalWindow') }}
      </span>
    </router-link-popup>
    <b-tooltip :target="popupBtnId" :placement="tooltipsPlacement">
      {{ $t('document.externalWindow') }}
    </b-tooltip>
  </component>
</template>

<script>
import { findIndex, uniqueId } from 'lodash'
import { mapState } from 'vuex'
import { FontAwesomeLayers } from '@fortawesome/vue-fontawesome'

import DocumentTypeCard from '@/components/DocumentTypeCard'
import RouterLinkPopup from '@/components/RouterLinkPopup'

/**
 * A list actions to apply to a document
 */
export default {
  name: 'DocumentActions',
  components: {
    DocumentTypeCard,
    FontAwesomeLayers,
    RouterLinkPopup
  },
  props: {
    /**
     * The selected document
     */
    document: {
      type: Object
    },
    /**
     * Use a vertical layout
     */
    vertical: {
      type: Boolean
    },
    /**
     * Tooltip's placement on each action
     * @values auto, top, bottom, left, right, topleft, topright, bottomleft, bottomright, lefttop, leftbottom, righttop, rightbottom
     */
    tooltipsPlacement: {
      type: String,
      default: 'top'
    },
    /**
     * Use a dropdown to download document without metadata
     */
    displayDownloadWithoutMetadata: {
      type: Boolean
    },
    /**
     * Show a dropdown item button to download extracted text when available
     */
    displayDownloadExtractedText: {
      type: Boolean,
      default: false
    },
    /**
     * True if download is allowed for the document
     */
    isDownloadAllowed: {
      type: Boolean
    },
    /**
     * Class to apply to the starring button
     */
    starBtnClass: {
      type: String,
      default: 'btn-link btn-sm'
    },
    /**
     * Class to apply to the starring button when document is starred
     */
    starredBtnClass: {
      type: String,
      default: 'starred'
    },
    /**
     * Class to apply to the download button
     */
    downloadBtnClass: {
      type: String,
      default: 'btn-link btn-sm'
    },
    /**
     * Class to apply to the download group button
     */
    downloadBtnGroupClass: {
      type: String,
      default: ''
    },
    /**
     * Class to apply to the popup button
     */
    popupBtnClass: {
      type: String,
      default: 'btn-link btn-sm'
    },
    /**
     * Show label for the starring button
     */
    starBtnLabel: {
      type: Boolean
    },
    /**
     * Show label for the download button
     */
    downloadBtnLabel: {
      type: Boolean
    },
    /**
     * Show label for the popup button
     */
    popupBtnLabel: {
      type: Boolean
    },
    /**
     * Disable the use of button group around each button
     */
    noBtnGroup: {
      type: Boolean
    }
  },
  data() {
    return {
      cleanableContentTypes: ['application/pdf', 'application/msword']
    }
  },
  computed: {
    ...mapState('starred', { starredDocuments: 'documents' }),
    isStarred() {
      const { index, id } = this.document
      return findIndex(this.starredDocuments, { index, id }) > -1
    },
    starBtnClassDefinition() {
      return {
        [this.starredBtnClass]: this.isStarred,
        ...this.classAttributeToObject(this.starBtnClass)
      }
    },
    starBtnId() {
      return uniqueId('document-actions-star-button-')
    },
    downloadBtnId() {
      return uniqueId('document-actions-download-button-')
    },
    downloadRootBtnId() {
      return uniqueId('document-actions-download-root-button-')
    },
    popupBtnId() {
      return uniqueId('document-actions-popup-button-')
    },
    documentFullUrlWithoutMetadata() {
      return this.document.fullUrl + '&filter_metadata=true'
    },
    rootDocumentFullUrlWithoutMetadata() {
      return this.document.fullRootUrl + '&filter_metadata=true'
    },
    canIDownload() {
      return this.isDownloadAllowed
    },
    hasRoot() {
      return this.document.root
    },
    hasCleanableContentType() {
      return this.cleanableContentTypes.includes(this.document.contentType)
    },
    hasRootCleanableContentType() {
      return this.hasRoot && this.cleanableContentTypes.includes(this.document.root.contentType)
    },
    hasContentLength() {
      return this.document?.contentTextLength > 0 || this.document?.contentLength > 0
    },
    hasDownloadDropdown() {
      return (
        this.hasRoot ||
        (this.hasCleanableContentType && this.displayDownloadWithoutMetadata) ||
        (this.hasRootCleanableContentType && this.displayDownloadWithoutMetadata) ||
        this.displayDownloadExtractedText
      )
    }
  },
  methods: {
    async documentOriginalExtractedText() {
      if (!this.document.content) {
        await this.$store.dispatch('document/getContent')
      }
      const a = document.createElement('a')
      a.href = URL.createObjectURL(new Blob([this.document.content], { type: 'text/plain;charset=UTF-8' }))
      a.download = `${this.document.title}.txt`
      a.click()
    },
    classAttributeToObject(str) {
      const list = str.split(' ')
      return Object.assign({}, ...list.map((key) => ({ [key]: true })))
    },
    async toggleStarDocument() {
      try {
        await this.$store.dispatch('starred/toggleStarDocument', this.document)
      } catch (_) {
        this.$bvToast.toast(this.$t('document.starringError'), { noCloseButton: true, variant: 'danger' })
      }
      this.$root.$emit('bv::hide::tooltip')
      this.$root.$emit('filter::starred::refresh')
    }
  }
}
</script>
