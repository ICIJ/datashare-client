<template>
  <component :is="baseComponent" v-bind="baseComponentProps">
    <span
      class="document-sliced-name"
      :class="{
        'document-sliced-name--sliced': isSliced,
        'document-sliced-name--truncate': hasActiveTextTruncate,
        'document-sliced-name--has-subject': hasSubject,
        'document-sliced-name--wrap': wrap
      }"
    >
      <span
        v-for="(slice, index) in slices"
        :key="index"
        class="document-sliced-name__item"
        :class="{ 'document-sliced-name__item--has-content-type': hasContentSlice(slice) }"
      >
        <span v-if="isMiddleSlice(slice)" class="text-nowrap"> … </span>
        <span v-else-if="hasContentSlice(slice)" class="d-inline-flex flex-row align-items-end">
          <span class="document-sliced-name__item__short-id">
            {{ slice }}
          </span>
          <span v-if="slice === document.shortId" class="document-sliced-name__item__content-type">
            {{ contentType }}
          </span>
        </span>
        <router-link
          v-else-if="hasInteractiveRoot"
          class="document-sliced-name__item__root"
          :to="{ name: 'document', params: rootParams }"
        >
          {{ slice }}
        </router-link>
        <span v-else class="document-sliced-name__item__single" :title="slice">
          {{ slice }}
        </span>
      </span>
      <span v-if="hasSubject" class="document-sliced-name__subject">
        {{ subject }}
      </span>
    </span>
  </component>
</template>

<script>
import { get, isString } from 'lodash'
import { ActiveTextTruncate } from '@icij/murmur-next'

import types from '@/utils/types.json'

/**
 * Display a document name in a sliced manner (to include parents).
 */
export default {
  props: {
    /**
     * The selected document
     */
    document: {
      type: Object
    },
    /**
     * Document's root should be links
     */
    interactiveRoot: {
      type: Boolean
    },
    /**
     * Use the active text truncate component to truncate the content.
     */
    activeTextTruncate: {
      type: [String, Boolean],
      default: null
    },
    /**
     * Direction for text truncate.
     */
    textTruncateRtlAttachments: {
      type: Boolean
    },
    /**
     * Add the document subject (if present)
     */
    showSubject: {
      type: Boolean
    },
    /**
     * Wrap title text (and disable activate text truncate)
     */
    wrap: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    slices() {
      return this.document.slicedName
    },
    subject() {
      return this.document.subject
    },
    contentType() {
      return get(types, [this.document.contentType, 'extensions'], [])[0]
    },
    rootParams() {
      const id = this.document.source.rootDocument || this.document.id
      const index = this.document.index
      return { id, index }
    },
    baseComponent() {
      return this.hasActiveTextTruncate ? ActiveTextTruncate : 'span'
    },
    baseComponentProps() {
      if (isString(this.activeTextTruncate) && this.activeTextTruncate !== '') {
        return { direction: this.activeTextTruncate }
      }
      if (this.textTruncateRtlAttachments && this.isSliced) {
        return { direction: 'rtl' }
      }
      return {}
    },
    hasInteractiveRoot() {
      return this.isSliced && this.interactiveRoot
    },
    hasActiveTextTruncate() {
      return !this.wrap && this.activeTextTruncate !== null
    },
    hasSubject() {
      return this.showSubject && !this.isSliced && this.document.hasSubject
    },
    isSliced() {
      return this.slices.length > 1
    }
  },
  methods: {
    isFirstSlice(slice) {
      return this.slices.indexOf(slice) === 0
    },
    isLastSlice(slice) {
      return this.slices.indexOf(slice) === this.slices.length - 1
    },
    isMiddleSlice(slice) {
      return !this.isFirstSlice(slice) && !this.isLastSlice(slice)
    },
    hasContentSlice(slice) {
      return !this.isFirstSlice(slice) && this.isLastSlice(slice)
    }
  }
}
</script>

<style lang="scss" scoped>
.document-sliced-name {
  display: inline-block;
  word-break: break-all;

  &--truncate:not(&--wrap) {
    white-space: nowrap;
    word-break: keep-all;
  }

  &__item {
    display: inline;

    // Slice separator
    &:not(:last-child):after {
      content: '❭';
      font-size: 0.5em;
      transform: translateY(-0.25em);
      line-height: 1em;
      opacity: 0.5;
      padding: 0 0.5em;
      display: inline-block;
    }

    &__content-type {
      font-weight: normal;
      opacity: 0.8;
    }

    &__root,
    &__root:hover {
      color: inherit;

      .document-sliced-name--sliced &:not(a) {
        font-weight: normal;
      }
    }

    .document-sliced-name--sliced &__root,
    .document-sliced-name--has-subject &__single {
      opacity: 0.5;
    }
  }
}
</style>
